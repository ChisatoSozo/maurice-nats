// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAY_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAY_CONTENT: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAY_CONTENT: [PlayContent; 3] = [
  PlayContent::NONE,
  PlayContent::PlayYoutube,
  PlayContent::PlayWav,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlayContent(pub u8);
#[allow(non_upper_case_globals)]
impl PlayContent {
  pub const NONE: Self = Self(0);
  pub const PlayYoutube: Self = Self(1);
  pub const PlayWav: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PlayYoutube,
    Self::PlayWav,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PlayYoutube => Some("PlayYoutube"),
      Self::PlayWav => Some("PlayWav"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlayContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlayContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlayContent {
    type Output = PlayContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlayContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlayContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlayContent {}
pub struct PlayContentUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPEAKER_COMMAND_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPEAKER_COMMAND_CONTENT: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPEAKER_COMMAND_CONTENT: [SpeakerCommandContent; 6] = [
  SpeakerCommandContent::NONE,
  SpeakerCommandContent::SetMusicVolume,
  SpeakerCommandContent::TogglePause,
  SpeakerCommandContent::Play,
  SpeakerCommandContent::Stop,
  SpeakerCommandContent::Seek,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpeakerCommandContent(pub u8);
#[allow(non_upper_case_globals)]
impl SpeakerCommandContent {
  pub const NONE: Self = Self(0);
  pub const SetMusicVolume: Self = Self(1);
  pub const TogglePause: Self = Self(2);
  pub const Play: Self = Self(3);
  pub const Stop: Self = Self(4);
  pub const Seek: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SetMusicVolume,
    Self::TogglePause,
    Self::Play,
    Self::Stop,
    Self::Seek,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SetMusicVolume => Some("SetMusicVolume"),
      Self::TogglePause => Some("TogglePause"),
      Self::Play => Some("Play"),
      Self::Stop => Some("Stop"),
      Self::Seek => Some("Seek"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SpeakerCommandContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpeakerCommandContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SpeakerCommandContent {
    type Output = SpeakerCommandContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SpeakerCommandContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpeakerCommandContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpeakerCommandContent {}
pub struct SpeakerCommandContentUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPEAKER_QUERY_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPEAKER_QUERY_CONTENT: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPEAKER_QUERY_CONTENT: [SpeakerQueryContent; 6] = [
  SpeakerQueryContent::NONE,
  SpeakerQueryContent::QueryMusicVolume,
  SpeakerQueryContent::QueryPause,
  SpeakerQueryContent::QueryPlay,
  SpeakerQueryContent::QuerySeek,
  SpeakerQueryContent::QueryDuration,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpeakerQueryContent(pub u8);
#[allow(non_upper_case_globals)]
impl SpeakerQueryContent {
  pub const NONE: Self = Self(0);
  pub const QueryMusicVolume: Self = Self(1);
  pub const QueryPause: Self = Self(2);
  pub const QueryPlay: Self = Self(3);
  pub const QuerySeek: Self = Self(4);
  pub const QueryDuration: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::QueryMusicVolume,
    Self::QueryPause,
    Self::QueryPlay,
    Self::QuerySeek,
    Self::QueryDuration,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::QueryMusicVolume => Some("QueryMusicVolume"),
      Self::QueryPause => Some("QueryPause"),
      Self::QueryPlay => Some("QueryPlay"),
      Self::QuerySeek => Some("QuerySeek"),
      Self::QueryDuration => Some("QueryDuration"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SpeakerQueryContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpeakerQueryContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SpeakerQueryContent {
    type Output = SpeakerQueryContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SpeakerQueryContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpeakerQueryContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpeakerQueryContent {}
pub struct SpeakerQueryContentUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPEAKER_EVENT_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPEAKER_EVENT_CONTENT: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPEAKER_EVENT_CONTENT: [SpeakerEventContent; 6] = [
  SpeakerEventContent::NONE,
  SpeakerEventContent::MusicVolumeChanged,
  SpeakerEventContent::PlayStarted,
  SpeakerEventContent::PlayStopped,
  SpeakerEventContent::SeekChanged,
  SpeakerEventContent::DurationChanged,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpeakerEventContent(pub u8);
#[allow(non_upper_case_globals)]
impl SpeakerEventContent {
  pub const NONE: Self = Self(0);
  pub const MusicVolumeChanged: Self = Self(1);
  pub const PlayStarted: Self = Self(2);
  pub const PlayStopped: Self = Self(3);
  pub const SeekChanged: Self = Self(4);
  pub const DurationChanged: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::MusicVolumeChanged,
    Self::PlayStarted,
    Self::PlayStopped,
    Self::SeekChanged,
    Self::DurationChanged,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::MusicVolumeChanged => Some("MusicVolumeChanged"),
      Self::PlayStarted => Some("PlayStarted"),
      Self::PlayStopped => Some("PlayStopped"),
      Self::SeekChanged => Some("SeekChanged"),
      Self::DurationChanged => Some("DurationChanged"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SpeakerEventContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpeakerEventContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SpeakerEventContent {
    type Output = SpeakerEventContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SpeakerEventContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpeakerEventContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpeakerEventContent {}
pub struct SpeakerEventContentUnionTableOffset {}

pub enum SetMusicVolumeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetMusicVolume<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetMusicVolume<'a> {
  type Inner = SetMusicVolume<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SetMusicVolume<'a> {
  pub const VT_VOLUME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SetMusicVolume { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SetMusicVolumeArgs
  ) -> flatbuffers::WIPOffset<SetMusicVolume<'bldr>> {
    let mut builder = SetMusicVolumeBuilder::new(_fbb);
    builder.add_volume(args.volume);
    builder.finish()
  }


  #[inline]
  pub fn volume(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SetMusicVolume::VT_VOLUME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SetMusicVolume<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("volume", Self::VT_VOLUME, false)?
     .finish();
    Ok(())
  }
}
pub struct SetMusicVolumeArgs {
    pub volume: f32,
}
impl<'a> Default for SetMusicVolumeArgs {
  #[inline]
  fn default() -> Self {
    SetMusicVolumeArgs {
      volume: 0.0,
    }
  }
}

pub struct SetMusicVolumeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetMusicVolumeBuilder<'a, 'b> {
  #[inline]
  pub fn add_volume(&mut self, volume: f32) {
    self.fbb_.push_slot::<f32>(SetMusicVolume::VT_VOLUME, volume, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetMusicVolumeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetMusicVolumeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetMusicVolume<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SetMusicVolume<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SetMusicVolume");
      ds.field("volume", &self.volume());
      ds.finish()
  }
}
pub enum TogglePauseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TogglePause<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TogglePause<'a> {
  type Inner = TogglePause<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TogglePause<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TogglePause { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TogglePauseArgs
  ) -> flatbuffers::WIPOffset<TogglePause<'bldr>> {
    let mut builder = TogglePauseBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for TogglePause<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TogglePauseArgs {
}
impl<'a> Default for TogglePauseArgs {
  #[inline]
  fn default() -> Self {
    TogglePauseArgs {
    }
  }
}

pub struct TogglePauseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TogglePauseBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TogglePauseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TogglePauseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TogglePause<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TogglePause<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TogglePause");
      ds.finish()
  }
}
pub enum PlayYoutubeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayYoutube<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayYoutube<'a> {
  type Inner = PlayYoutube<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayYoutube<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayYoutube { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayYoutubeArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayYoutube<'bldr>> {
    let mut builder = PlayYoutubeBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }


  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlayYoutube::VT_URL, None)}
  }
}

impl flatbuffers::Verifiable for PlayYoutube<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayYoutubeArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PlayYoutubeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayYoutubeArgs {
      url: None,
    }
  }
}

pub struct PlayYoutubeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayYoutubeBuilder<'a, 'b> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayYoutube::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayYoutubeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayYoutubeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayYoutube<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayYoutube<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayYoutube");
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum PlayWavOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayWav<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayWav<'a> {
  type Inner = PlayWav<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayWav<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayWav { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayWavArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayWav<'bldr>> {
    let mut builder = PlayWavBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PlayWav::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PlayWav<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayWavArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for PlayWavArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayWavArgs {
      data: None,
    }
  }
}

pub struct PlayWavBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayWavBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayWav::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayWavBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayWavBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayWav<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayWav<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayWav");
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum PlayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Play<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Play<'a> {
  type Inner = Play<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Play<'a> {
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Play { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayArgs
  ) -> flatbuffers::WIPOffset<Play<'bldr>> {
    let mut builder = PlayBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_content_type(args.content_type);
    builder.finish()
  }


  #[inline]
  pub fn content_type(&self) -> PlayContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlayContent>(Play::VT_CONTENT_TYPE, Some(PlayContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Play::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_play_youtube(&self) -> Option<PlayYoutube<'a>> {
    if self.content_type() == PlayContent::PlayYoutube {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayYoutube::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_play_wav(&self) -> Option<PlayWav<'a>> {
    if self.content_type() == PlayContent::PlayWav {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayWav::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Play<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<PlayContent, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          PlayContent::PlayYoutube => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayYoutube>>("PlayContent::PlayYoutube", pos),
          PlayContent::PlayWav => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayWav>>("PlayContent::PlayWav", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PlayArgs {
    pub content_type: PlayContent,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PlayArgs {
  #[inline]
  fn default() -> Self {
    PlayArgs {
      content_type: PlayContent::NONE,
      content: None,
    }
  }
}

pub struct PlayBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayBuilder<'a, 'b> {
  #[inline]
  pub fn add_content_type(&mut self, content_type: PlayContent) {
    self.fbb_.push_slot::<PlayContent>(Play::VT_CONTENT_TYPE, content_type, PlayContent::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Play::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Play<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Play<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Play");
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        PlayContent::PlayYoutube => {
          if let Some(x) = self.content_as_play_youtube() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlayContent::PlayWav => {
          if let Some(x) = self.content_as_play_wav() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
pub enum StopOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Stop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Stop<'a> {
  type Inner = Stop<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Stop<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Stop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args StopArgs
  ) -> flatbuffers::WIPOffset<Stop<'bldr>> {
    let mut builder = StopBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Stop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct StopArgs {
}
impl<'a> Default for StopArgs {
  #[inline]
  fn default() -> Self {
    StopArgs {
    }
  }
}

pub struct StopBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StopBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StopBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StopBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Stop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Stop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Stop");
      ds.finish()
  }
}
pub enum SeekOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Seek<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Seek<'a> {
  type Inner = Seek<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Seek<'a> {
  pub const VT_SEEK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Seek { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SeekArgs
  ) -> flatbuffers::WIPOffset<Seek<'bldr>> {
    let mut builder = SeekBuilder::new(_fbb);
    builder.add_seek(args.seek);
    builder.finish()
  }


  #[inline]
  pub fn seek(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Seek::VT_SEEK, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Seek<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("seek", Self::VT_SEEK, false)?
     .finish();
    Ok(())
  }
}
pub struct SeekArgs {
    pub seek: f32,
}
impl<'a> Default for SeekArgs {
  #[inline]
  fn default() -> Self {
    SeekArgs {
      seek: 0.0,
    }
  }
}

pub struct SeekBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SeekBuilder<'a, 'b> {
  #[inline]
  pub fn add_seek(&mut self, seek: f32) {
    self.fbb_.push_slot::<f32>(Seek::VT_SEEK, seek, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SeekBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SeekBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Seek<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Seek<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Seek");
      ds.field("seek", &self.seek());
      ds.finish()
  }
}
pub enum QueryMusicVolumeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QueryMusicVolume<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryMusicVolume<'a> {
  type Inner = QueryMusicVolume<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QueryMusicVolume<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QueryMusicVolume { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QueryMusicVolumeArgs
  ) -> flatbuffers::WIPOffset<QueryMusicVolume<'bldr>> {
    let mut builder = QueryMusicVolumeBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QueryMusicVolume<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QueryMusicVolumeArgs {
}
impl<'a> Default for QueryMusicVolumeArgs {
  #[inline]
  fn default() -> Self {
    QueryMusicVolumeArgs {
    }
  }
}

pub struct QueryMusicVolumeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryMusicVolumeBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryMusicVolumeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryMusicVolumeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryMusicVolume<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QueryMusicVolume<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QueryMusicVolume");
      ds.finish()
  }
}
pub enum QueryPauseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QueryPause<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryPause<'a> {
  type Inner = QueryPause<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QueryPause<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QueryPause { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QueryPauseArgs
  ) -> flatbuffers::WIPOffset<QueryPause<'bldr>> {
    let mut builder = QueryPauseBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QueryPause<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QueryPauseArgs {
}
impl<'a> Default for QueryPauseArgs {
  #[inline]
  fn default() -> Self {
    QueryPauseArgs {
    }
  }
}

pub struct QueryPauseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryPauseBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryPauseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryPauseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryPause<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QueryPause<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QueryPause");
      ds.finish()
  }
}
pub enum QueryPlayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QueryPlay<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryPlay<'a> {
  type Inner = QueryPlay<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QueryPlay<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QueryPlay { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QueryPlayArgs
  ) -> flatbuffers::WIPOffset<QueryPlay<'bldr>> {
    let mut builder = QueryPlayBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QueryPlay<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QueryPlayArgs {
}
impl<'a> Default for QueryPlayArgs {
  #[inline]
  fn default() -> Self {
    QueryPlayArgs {
    }
  }
}

pub struct QueryPlayBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryPlayBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryPlayBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryPlayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryPlay<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QueryPlay<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QueryPlay");
      ds.finish()
  }
}
pub enum QuerySeekOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuerySeek<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuerySeek<'a> {
  type Inner = QuerySeek<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuerySeek<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuerySeek { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QuerySeekArgs
  ) -> flatbuffers::WIPOffset<QuerySeek<'bldr>> {
    let mut builder = QuerySeekBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QuerySeek<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QuerySeekArgs {
}
impl<'a> Default for QuerySeekArgs {
  #[inline]
  fn default() -> Self {
    QuerySeekArgs {
    }
  }
}

pub struct QuerySeekBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuerySeekBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuerySeekBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuerySeekBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuerySeek<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuerySeek<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuerySeek");
      ds.finish()
  }
}
pub enum QueryDurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QueryDuration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryDuration<'a> {
  type Inner = QueryDuration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QueryDuration<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QueryDuration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QueryDurationArgs
  ) -> flatbuffers::WIPOffset<QueryDuration<'bldr>> {
    let mut builder = QueryDurationBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QueryDuration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QueryDurationArgs {
}
impl<'a> Default for QueryDurationArgs {
  #[inline]
  fn default() -> Self {
    QueryDurationArgs {
    }
  }
}

pub struct QueryDurationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryDurationBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryDurationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryDurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryDuration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QueryDuration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QueryDuration");
      ds.finish()
  }
}
pub enum MusicVolumeChangedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MusicVolumeChanged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MusicVolumeChanged<'a> {
  type Inner = MusicVolumeChanged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MusicVolumeChanged<'a> {
  pub const VT_VOLUME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MusicVolumeChanged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MusicVolumeChangedArgs
  ) -> flatbuffers::WIPOffset<MusicVolumeChanged<'bldr>> {
    let mut builder = MusicVolumeChangedBuilder::new(_fbb);
    builder.add_volume(args.volume);
    builder.finish()
  }


  #[inline]
  pub fn volume(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MusicVolumeChanged::VT_VOLUME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MusicVolumeChanged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("volume", Self::VT_VOLUME, false)?
     .finish();
    Ok(())
  }
}
pub struct MusicVolumeChangedArgs {
    pub volume: f32,
}
impl<'a> Default for MusicVolumeChangedArgs {
  #[inline]
  fn default() -> Self {
    MusicVolumeChangedArgs {
      volume: 0.0,
    }
  }
}

pub struct MusicVolumeChangedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MusicVolumeChangedBuilder<'a, 'b> {
  #[inline]
  pub fn add_volume(&mut self, volume: f32) {
    self.fbb_.push_slot::<f32>(MusicVolumeChanged::VT_VOLUME, volume, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MusicVolumeChangedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MusicVolumeChangedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MusicVolumeChanged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MusicVolumeChanged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MusicVolumeChanged");
      ds.field("volume", &self.volume());
      ds.finish()
  }
}
pub enum PlayStartedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayStarted<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayStarted<'a> {
  type Inner = PlayStarted<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayStarted<'a> {
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayStarted { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayStartedArgs
  ) -> flatbuffers::WIPOffset<PlayStarted<'bldr>> {
    let mut builder = PlayStartedBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_content_type(args.content_type);
    builder.finish()
  }


  #[inline]
  pub fn content_type(&self) -> PlayContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlayContent>(PlayStarted::VT_CONTENT_TYPE, Some(PlayContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PlayStarted::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_play_youtube(&self) -> Option<PlayYoutube<'a>> {
    if self.content_type() == PlayContent::PlayYoutube {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayYoutube::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_play_wav(&self) -> Option<PlayWav<'a>> {
    if self.content_type() == PlayContent::PlayWav {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayWav::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PlayStarted<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<PlayContent, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          PlayContent::PlayYoutube => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayYoutube>>("PlayContent::PlayYoutube", pos),
          PlayContent::PlayWav => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayWav>>("PlayContent::PlayWav", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PlayStartedArgs {
    pub content_type: PlayContent,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PlayStartedArgs {
  #[inline]
  fn default() -> Self {
    PlayStartedArgs {
      content_type: PlayContent::NONE,
      content: None,
    }
  }
}

pub struct PlayStartedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayStartedBuilder<'a, 'b> {
  #[inline]
  pub fn add_content_type(&mut self, content_type: PlayContent) {
    self.fbb_.push_slot::<PlayContent>(PlayStarted::VT_CONTENT_TYPE, content_type, PlayContent::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayStarted::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayStartedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayStartedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayStarted<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayStarted<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayStarted");
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        PlayContent::PlayYoutube => {
          if let Some(x) = self.content_as_play_youtube() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlayContent::PlayWav => {
          if let Some(x) = self.content_as_play_wav() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
pub enum PlayStoppedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayStopped<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayStopped<'a> {
  type Inner = PlayStopped<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayStopped<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayStopped { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PlayStoppedArgs
  ) -> flatbuffers::WIPOffset<PlayStopped<'bldr>> {
    let mut builder = PlayStoppedBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for PlayStopped<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PlayStoppedArgs {
}
impl<'a> Default for PlayStoppedArgs {
  #[inline]
  fn default() -> Self {
    PlayStoppedArgs {
    }
  }
}

pub struct PlayStoppedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayStoppedBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayStoppedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayStoppedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayStopped<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayStopped<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayStopped");
      ds.finish()
  }
}
pub enum SeekChangedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SeekChanged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SeekChanged<'a> {
  type Inner = SeekChanged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SeekChanged<'a> {
  pub const VT_SEEK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SeekChanged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SeekChangedArgs
  ) -> flatbuffers::WIPOffset<SeekChanged<'bldr>> {
    let mut builder = SeekChangedBuilder::new(_fbb);
    builder.add_seek(args.seek);
    builder.finish()
  }


  #[inline]
  pub fn seek(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SeekChanged::VT_SEEK, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SeekChanged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("seek", Self::VT_SEEK, false)?
     .finish();
    Ok(())
  }
}
pub struct SeekChangedArgs {
    pub seek: f32,
}
impl<'a> Default for SeekChangedArgs {
  #[inline]
  fn default() -> Self {
    SeekChangedArgs {
      seek: 0.0,
    }
  }
}

pub struct SeekChangedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SeekChangedBuilder<'a, 'b> {
  #[inline]
  pub fn add_seek(&mut self, seek: f32) {
    self.fbb_.push_slot::<f32>(SeekChanged::VT_SEEK, seek, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SeekChangedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SeekChangedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SeekChanged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SeekChanged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SeekChanged");
      ds.field("seek", &self.seek());
      ds.finish()
  }
}
pub enum DurationChangedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DurationChanged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DurationChanged<'a> {
  type Inner = DurationChanged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DurationChanged<'a> {
  pub const VT_DURATION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DurationChanged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DurationChangedArgs
  ) -> flatbuffers::WIPOffset<DurationChanged<'bldr>> {
    let mut builder = DurationChangedBuilder::new(_fbb);
    builder.add_duration(args.duration);
    builder.finish()
  }


  #[inline]
  pub fn duration(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DurationChanged::VT_DURATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DurationChanged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("duration", Self::VT_DURATION, false)?
     .finish();
    Ok(())
  }
}
pub struct DurationChangedArgs {
    pub duration: f32,
}
impl<'a> Default for DurationChangedArgs {
  #[inline]
  fn default() -> Self {
    DurationChangedArgs {
      duration: 0.0,
    }
  }
}

pub struct DurationChangedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DurationChangedBuilder<'a, 'b> {
  #[inline]
  pub fn add_duration(&mut self, duration: f32) {
    self.fbb_.push_slot::<f32>(DurationChanged::VT_DURATION, duration, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DurationChangedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DurationChangedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DurationChanged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DurationChanged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DurationChanged");
      ds.field("duration", &self.duration());
      ds.finish()
  }
}
pub enum SpeakerCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeakerCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeakerCommand<'a> {
  type Inner = SpeakerCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeakerCommand<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeakerCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpeakerCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<SpeakerCommand<'bldr>> {
    let mut builder = SpeakerCommandBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SpeakerCommand::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn command_type(&self) -> SpeakerCommandContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpeakerCommandContent>(SpeakerCommand::VT_COMMAND_TYPE, Some(SpeakerCommandContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SpeakerCommand::VT_COMMAND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_set_music_volume(&self) -> Option<SetMusicVolume<'a>> {
    if self.command_type() == SpeakerCommandContent::SetMusicVolume {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SetMusicVolume::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_toggle_pause(&self) -> Option<TogglePause<'a>> {
    if self.command_type() == SpeakerCommandContent::TogglePause {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TogglePause::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_play(&self) -> Option<Play<'a>> {
    if self.command_type() == SpeakerCommandContent::Play {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Play::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_stop(&self) -> Option<Stop<'a>> {
    if self.command_type() == SpeakerCommandContent::Stop {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Stop::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_seek(&self) -> Option<Seek<'a>> {
    if self.command_type() == SpeakerCommandContent::Seek {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Seek::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SpeakerCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<SpeakerCommandContent, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, false, |key, v, pos| {
        match key {
          SpeakerCommandContent::SetMusicVolume => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetMusicVolume>>("SpeakerCommandContent::SetMusicVolume", pos),
          SpeakerCommandContent::TogglePause => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TogglePause>>("SpeakerCommandContent::TogglePause", pos),
          SpeakerCommandContent::Play => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Play>>("SpeakerCommandContent::Play", pos),
          SpeakerCommandContent::Stop => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Stop>>("SpeakerCommandContent::Stop", pos),
          SpeakerCommandContent::Seek => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Seek>>("SpeakerCommandContent::Seek", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SpeakerCommandArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub command_type: SpeakerCommandContent,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SpeakerCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpeakerCommandArgs {
      device_id: None,
      command_type: SpeakerCommandContent::NONE,
      command: None,
    }
  }
}

pub struct SpeakerCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeakerCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerCommand::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_command_type(&mut self, command_type: SpeakerCommandContent) {
    self.fbb_.push_slot::<SpeakerCommandContent>(SpeakerCommand::VT_COMMAND_TYPE, command_type, SpeakerCommandContent::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerCommand::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeakerCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeakerCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeakerCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeakerCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeakerCommand");
      ds.field("device_id", &self.device_id());
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        SpeakerCommandContent::SetMusicVolume => {
          if let Some(x) = self.command_as_set_music_volume() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerCommandContent::TogglePause => {
          if let Some(x) = self.command_as_toggle_pause() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerCommandContent::Play => {
          if let Some(x) = self.command_as_play() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerCommandContent::Stop => {
          if let Some(x) = self.command_as_stop() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerCommandContent::Seek => {
          if let Some(x) = self.command_as_seek() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
pub enum SpeakerQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeakerQuery<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeakerQuery<'a> {
  type Inner = SpeakerQuery<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeakerQuery<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_QUERY_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_QUERY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeakerQuery { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpeakerQueryArgs<'args>
  ) -> flatbuffers::WIPOffset<SpeakerQuery<'bldr>> {
    let mut builder = SpeakerQueryBuilder::new(_fbb);
    if let Some(x) = args.query { builder.add_query(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_query_type(args.query_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SpeakerQuery::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn query_type(&self) -> SpeakerQueryContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpeakerQueryContent>(SpeakerQuery::VT_QUERY_TYPE, Some(SpeakerQueryContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn query(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SpeakerQuery::VT_QUERY, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_music_volume(&self) -> Option<QueryMusicVolume<'a>> {
    if self.query_type() == SpeakerQueryContent::QueryMusicVolume {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QueryMusicVolume::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_pause(&self) -> Option<QueryPause<'a>> {
    if self.query_type() == SpeakerQueryContent::QueryPause {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QueryPause::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_play(&self) -> Option<QueryPlay<'a>> {
    if self.query_type() == SpeakerQueryContent::QueryPlay {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QueryPlay::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_seek(&self) -> Option<QuerySeek<'a>> {
    if self.query_type() == SpeakerQueryContent::QuerySeek {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QuerySeek::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_duration(&self) -> Option<QueryDuration<'a>> {
    if self.query_type() == SpeakerQueryContent::QueryDuration {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QueryDuration::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SpeakerQuery<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<SpeakerQueryContent, _>("query_type", Self::VT_QUERY_TYPE, "query", Self::VT_QUERY, false, |key, v, pos| {
        match key {
          SpeakerQueryContent::QueryMusicVolume => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QueryMusicVolume>>("SpeakerQueryContent::QueryMusicVolume", pos),
          SpeakerQueryContent::QueryPause => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QueryPause>>("SpeakerQueryContent::QueryPause", pos),
          SpeakerQueryContent::QueryPlay => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QueryPlay>>("SpeakerQueryContent::QueryPlay", pos),
          SpeakerQueryContent::QuerySeek => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QuerySeek>>("SpeakerQueryContent::QuerySeek", pos),
          SpeakerQueryContent::QueryDuration => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QueryDuration>>("SpeakerQueryContent::QueryDuration", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SpeakerQueryArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query_type: SpeakerQueryContent,
    pub query: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SpeakerQueryArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpeakerQueryArgs {
      device_id: None,
      query_type: SpeakerQueryContent::NONE,
      query: None,
    }
  }
}

pub struct SpeakerQueryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeakerQueryBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerQuery::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_query_type(&mut self, query_type: SpeakerQueryContent) {
    self.fbb_.push_slot::<SpeakerQueryContent>(SpeakerQuery::VT_QUERY_TYPE, query_type, SpeakerQueryContent::NONE);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerQuery::VT_QUERY, query);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeakerQueryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeakerQueryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeakerQuery<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeakerQuery<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeakerQuery");
      ds.field("device_id", &self.device_id());
      ds.field("query_type", &self.query_type());
      match self.query_type() {
        SpeakerQueryContent::QueryMusicVolume => {
          if let Some(x) = self.query_as_query_music_volume() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerQueryContent::QueryPause => {
          if let Some(x) = self.query_as_query_pause() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerQueryContent::QueryPlay => {
          if let Some(x) = self.query_as_query_play() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerQueryContent::QuerySeek => {
          if let Some(x) = self.query_as_query_seek() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerQueryContent::QueryDuration => {
          if let Some(x) = self.query_as_query_duration() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("query", &x)
        },
      };
      ds.finish()
  }
}
pub enum SpeakerListQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeakerListQuery<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeakerListQuery<'a> {
  type Inner = SpeakerListQuery<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeakerListQuery<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeakerListQuery { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SpeakerListQueryArgs
  ) -> flatbuffers::WIPOffset<SpeakerListQuery<'bldr>> {
    let mut builder = SpeakerListQueryBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for SpeakerListQuery<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SpeakerListQueryArgs {
}
impl<'a> Default for SpeakerListQueryArgs {
  #[inline]
  fn default() -> Self {
    SpeakerListQueryArgs {
    }
  }
}

pub struct SpeakerListQueryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeakerListQueryBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeakerListQueryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeakerListQueryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeakerListQuery<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeakerListQuery<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeakerListQuery");
      ds.finish()
  }
}
pub enum SpeakerEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeakerEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeakerEvent<'a> {
  type Inner = SpeakerEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeakerEvent<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_EVENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeakerEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpeakerEventArgs<'args>
  ) -> flatbuffers::WIPOffset<SpeakerEvent<'bldr>> {
    let mut builder = SpeakerEventBuilder::new(_fbb);
    if let Some(x) = args.event { builder.add_event(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_event_type(args.event_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SpeakerEvent::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn event_type(&self) -> SpeakerEventContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpeakerEventContent>(SpeakerEvent::VT_EVENT_TYPE, Some(SpeakerEventContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SpeakerEvent::VT_EVENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_music_volume_changed(&self) -> Option<MusicVolumeChanged<'a>> {
    if self.event_type() == SpeakerEventContent::MusicVolumeChanged {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MusicVolumeChanged::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_play_started(&self) -> Option<PlayStarted<'a>> {
    if self.event_type() == SpeakerEventContent::PlayStarted {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayStarted::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_play_stopped(&self) -> Option<PlayStopped<'a>> {
    if self.event_type() == SpeakerEventContent::PlayStopped {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayStopped::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_seek_changed(&self) -> Option<SeekChanged<'a>> {
    if self.event_type() == SpeakerEventContent::SeekChanged {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SeekChanged::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_duration_changed(&self) -> Option<DurationChanged<'a>> {
    if self.event_type() == SpeakerEventContent::DurationChanged {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DurationChanged::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SpeakerEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<SpeakerEventContent, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, false, |key, v, pos| {
        match key {
          SpeakerEventContent::MusicVolumeChanged => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MusicVolumeChanged>>("SpeakerEventContent::MusicVolumeChanged", pos),
          SpeakerEventContent::PlayStarted => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayStarted>>("SpeakerEventContent::PlayStarted", pos),
          SpeakerEventContent::PlayStopped => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayStopped>>("SpeakerEventContent::PlayStopped", pos),
          SpeakerEventContent::SeekChanged => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SeekChanged>>("SpeakerEventContent::SeekChanged", pos),
          SpeakerEventContent::DurationChanged => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DurationChanged>>("SpeakerEventContent::DurationChanged", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SpeakerEventArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_type: SpeakerEventContent,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SpeakerEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpeakerEventArgs {
      device_id: None,
      event_type: SpeakerEventContent::NONE,
      event: None,
    }
  }
}

pub struct SpeakerEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeakerEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerEvent::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_event_type(&mut self, event_type: SpeakerEventContent) {
    self.fbb_.push_slot::<SpeakerEventContent>(SpeakerEvent::VT_EVENT_TYPE, event_type, SpeakerEventContent::NONE);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerEvent::VT_EVENT, event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeakerEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeakerEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeakerEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeakerEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeakerEvent");
      ds.field("device_id", &self.device_id());
      ds.field("event_type", &self.event_type());
      match self.event_type() {
        SpeakerEventContent::MusicVolumeChanged => {
          if let Some(x) = self.event_as_music_volume_changed() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerEventContent::PlayStarted => {
          if let Some(x) = self.event_as_play_started() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerEventContent::PlayStopped => {
          if let Some(x) = self.event_as_play_stopped() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerEventContent::SeekChanged => {
          if let Some(x) = self.event_as_seek_changed() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpeakerEventContent::DurationChanged => {
          if let Some(x) = self.event_as_duration_changed() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("event", &x)
        },
      };
      ds.finish()
  }
}
pub enum SpeakerListEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeakerListEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeakerListEvent<'a> {
  type Inner = SpeakerListEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeakerListEvent<'a> {
  pub const VT_DEVICE_IDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeakerListEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpeakerListEventArgs<'args>
  ) -> flatbuffers::WIPOffset<SpeakerListEvent<'bldr>> {
    let mut builder = SpeakerListEventBuilder::new(_fbb);
    if let Some(x) = args.device_ids { builder.add_device_ids(x); }
    builder.finish()
  }


  #[inline]
  pub fn device_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SpeakerListEvent::VT_DEVICE_IDS, None)}
  }
}

impl flatbuffers::Verifiable for SpeakerListEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("device_ids", Self::VT_DEVICE_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SpeakerListEventArgs<'a> {
    pub device_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SpeakerListEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpeakerListEventArgs {
      device_ids: None,
    }
  }
}

pub struct SpeakerListEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeakerListEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_ids(&mut self, device_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SpeakerListEvent::VT_DEVICE_IDS, device_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeakerListEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeakerListEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeakerListEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeakerListEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeakerListEvent");
      ds.field("device_ids", &self.device_ids());
      ds.finish()
  }
}
