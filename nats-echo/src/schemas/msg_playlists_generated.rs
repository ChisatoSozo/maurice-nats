// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAYLIST_COMMAND_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAYLIST_COMMAND_CONTENT: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAYLIST_COMMAND_CONTENT: [PlaylistCommandContent; 5] = [
  PlaylistCommandContent::NONE,
  PlaylistCommandContent::AddSong,
  PlaylistCommandContent::ReplaceSong,
  PlaylistCommandContent::RemoveSong,
  PlaylistCommandContent::InsertSong,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlaylistCommandContent(pub u8);
#[allow(non_upper_case_globals)]
impl PlaylistCommandContent {
  pub const NONE: Self = Self(0);
  pub const AddSong: Self = Self(1);
  pub const ReplaceSong: Self = Self(2);
  pub const RemoveSong: Self = Self(3);
  pub const InsertSong: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AddSong,
    Self::ReplaceSong,
    Self::RemoveSong,
    Self::InsertSong,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::AddSong => Some("AddSong"),
      Self::ReplaceSong => Some("ReplaceSong"),
      Self::RemoveSong => Some("RemoveSong"),
      Self::InsertSong => Some("InsertSong"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlaylistCommandContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlaylistCommandContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlaylistCommandContent {
    type Output = PlaylistCommandContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlaylistCommandContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlaylistCommandContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlaylistCommandContent {}
pub struct PlaylistCommandContentUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAYLIST_QUERY_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAYLIST_QUERY_CONTENT: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAYLIST_QUERY_CONTENT: [PlaylistQueryContent; 2] = [
  PlaylistQueryContent::NONE,
  PlaylistQueryContent::QueryPlaylistState,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlaylistQueryContent(pub u8);
#[allow(non_upper_case_globals)]
impl PlaylistQueryContent {
  pub const NONE: Self = Self(0);
  pub const QueryPlaylistState: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::QueryPlaylistState,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::QueryPlaylistState => Some("QueryPlaylistState"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlaylistQueryContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlaylistQueryContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlaylistQueryContent {
    type Output = PlaylistQueryContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlaylistQueryContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlaylistQueryContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlaylistQueryContent {}
pub struct PlaylistQueryContentUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAYLIST_EVENT_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAYLIST_EVENT_CONTENT: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAYLIST_EVENT_CONTENT: [PlaylistEventContent; 2] = [
  PlaylistEventContent::NONE,
  PlaylistEventContent::PlaylistStateChanged,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlaylistEventContent(pub u8);
#[allow(non_upper_case_globals)]
impl PlaylistEventContent {
  pub const NONE: Self = Self(0);
  pub const PlaylistStateChanged: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PlaylistStateChanged,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PlaylistStateChanged => Some("PlaylistStateChanged"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlaylistEventContent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlaylistEventContent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlaylistEventContent {
    type Output = PlaylistEventContent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlaylistEventContent {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlaylistEventContent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlaylistEventContent {}
pub struct PlaylistEventContentUnionTableOffset {}

pub enum SongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Song<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Song<'a> {
  type Inner = Song<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Song<'a> {
  pub const VT_URL: flatbuffers::VOffsetT = 4;
  pub const VT_THUMBNAIL_B64: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Song { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SongArgs<'args>
  ) -> flatbuffers::WIPOffset<Song<'bldr>> {
    let mut builder = SongBuilder::new(_fbb);
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.thumbnail_b64 { builder.add_thumbnail_b64(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    builder.finish()
  }


  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Song::VT_URL, None)}
  }
  #[inline]
  pub fn thumbnail_b64(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Song::VT_THUMBNAIL_B64, None)}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Song::VT_TITLE, None)}
  }
}

impl flatbuffers::Verifiable for Song<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("thumbnail_b64", Self::VT_THUMBNAIL_B64, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .finish();
    Ok(())
  }
}
pub struct SongArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub thumbnail_b64: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SongArgs<'a> {
  #[inline]
  fn default() -> Self {
    SongArgs {
      url: None,
      thumbnail_b64: None,
      title: None,
    }
  }
}

pub struct SongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SongBuilder<'a, 'b> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Song::VT_URL, url);
  }
  #[inline]
  pub fn add_thumbnail_b64(&mut self, thumbnail_b64: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Song::VT_THUMBNAIL_B64, thumbnail_b64);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Song::VT_TITLE, title);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Song<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Song<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Song");
      ds.field("url", &self.url());
      ds.field("thumbnail_b64", &self.thumbnail_b64());
      ds.field("title", &self.title());
      ds.finish()
  }
}
pub enum AddSongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddSong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddSong<'a> {
  type Inner = AddSong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AddSong<'a> {
  pub const VT_SONG: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddSong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddSongArgs<'args>
  ) -> flatbuffers::WIPOffset<AddSong<'bldr>> {
    let mut builder = AddSongBuilder::new(_fbb);
    if let Some(x) = args.song { builder.add_song(x); }
    builder.finish()
  }


  #[inline]
  pub fn song(&self) -> Option<Song<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Song>>(AddSong::VT_SONG, None)}
  }
}

impl flatbuffers::Verifiable for AddSong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Song>>("song", Self::VT_SONG, false)?
     .finish();
    Ok(())
  }
}
pub struct AddSongArgs<'a> {
    pub song: Option<flatbuffers::WIPOffset<Song<'a>>>,
}
impl<'a> Default for AddSongArgs<'a> {
  #[inline]
  fn default() -> Self {
    AddSongArgs {
      song: None,
    }
  }
}

pub struct AddSongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddSongBuilder<'a, 'b> {
  #[inline]
  pub fn add_song(&mut self, song: flatbuffers::WIPOffset<Song<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Song>>(AddSong::VT_SONG, song);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddSongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddSongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddSong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddSong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddSong");
      ds.field("song", &self.song());
      ds.finish()
  }
}
pub enum ReplaceSongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReplaceSong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReplaceSong<'a> {
  type Inner = ReplaceSong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReplaceSong<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_SONG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReplaceSong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReplaceSongArgs<'args>
  ) -> flatbuffers::WIPOffset<ReplaceSong<'bldr>> {
    let mut builder = ReplaceSongBuilder::new(_fbb);
    if let Some(x) = args.song { builder.add_song(x); }
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ReplaceSong::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn song(&self) -> Option<Song<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Song>>(ReplaceSong::VT_SONG, None)}
  }
}

impl flatbuffers::Verifiable for ReplaceSong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Song>>("song", Self::VT_SONG, false)?
     .finish();
    Ok(())
  }
}
pub struct ReplaceSongArgs<'a> {
    pub index: i32,
    pub song: Option<flatbuffers::WIPOffset<Song<'a>>>,
}
impl<'a> Default for ReplaceSongArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReplaceSongArgs {
      index: 0,
      song: None,
    }
  }
}

pub struct ReplaceSongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReplaceSongBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(ReplaceSong::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_song(&mut self, song: flatbuffers::WIPOffset<Song<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Song>>(ReplaceSong::VT_SONG, song);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReplaceSongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReplaceSongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReplaceSong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReplaceSong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReplaceSong");
      ds.field("index", &self.index());
      ds.field("song", &self.song());
      ds.finish()
  }
}
pub enum RemoveSongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RemoveSong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemoveSong<'a> {
  type Inner = RemoveSong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RemoveSong<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RemoveSong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RemoveSongArgs
  ) -> flatbuffers::WIPOffset<RemoveSong<'bldr>> {
    let mut builder = RemoveSongBuilder::new(_fbb);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RemoveSong::VT_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RemoveSong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct RemoveSongArgs {
    pub index: i32,
}
impl<'a> Default for RemoveSongArgs {
  #[inline]
  fn default() -> Self {
    RemoveSongArgs {
      index: 0,
    }
  }
}

pub struct RemoveSongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RemoveSongBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(RemoveSong::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RemoveSongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RemoveSongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RemoveSong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RemoveSong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RemoveSong");
      ds.field("index", &self.index());
      ds.finish()
  }
}
pub enum InsertSongOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InsertSong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InsertSong<'a> {
  type Inner = InsertSong<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InsertSong<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_SONG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InsertSong { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InsertSongArgs<'args>
  ) -> flatbuffers::WIPOffset<InsertSong<'bldr>> {
    let mut builder = InsertSongBuilder::new(_fbb);
    if let Some(x) = args.song { builder.add_song(x); }
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(InsertSong::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn song(&self) -> Option<Song<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Song>>(InsertSong::VT_SONG, None)}
  }
}

impl flatbuffers::Verifiable for InsertSong<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Song>>("song", Self::VT_SONG, false)?
     .finish();
    Ok(())
  }
}
pub struct InsertSongArgs<'a> {
    pub index: i32,
    pub song: Option<flatbuffers::WIPOffset<Song<'a>>>,
}
impl<'a> Default for InsertSongArgs<'a> {
  #[inline]
  fn default() -> Self {
    InsertSongArgs {
      index: 0,
      song: None,
    }
  }
}

pub struct InsertSongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InsertSongBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(InsertSong::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_song(&mut self, song: flatbuffers::WIPOffset<Song<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Song>>(InsertSong::VT_SONG, song);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InsertSongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InsertSongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InsertSong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InsertSong<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InsertSong");
      ds.field("index", &self.index());
      ds.field("song", &self.song());
      ds.finish()
  }
}
pub enum QueryPlaylistStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QueryPlaylistState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryPlaylistState<'a> {
  type Inner = QueryPlaylistState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QueryPlaylistState<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QueryPlaylistState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QueryPlaylistStateArgs
  ) -> flatbuffers::WIPOffset<QueryPlaylistState<'bldr>> {
    let mut builder = QueryPlaylistStateBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for QueryPlaylistState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QueryPlaylistStateArgs {
}
impl<'a> Default for QueryPlaylistStateArgs {
  #[inline]
  fn default() -> Self {
    QueryPlaylistStateArgs {
    }
  }
}

pub struct QueryPlaylistStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryPlaylistStateBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryPlaylistStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryPlaylistStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryPlaylistState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QueryPlaylistState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QueryPlaylistState");
      ds.finish()
  }
}
pub enum PlaylistStateChangedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlaylistStateChanged<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaylistStateChanged<'a> {
  type Inner = PlaylistStateChanged<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlaylistStateChanged<'a> {
  pub const VT_SONGS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlaylistStateChanged { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlaylistStateChangedArgs<'args>
  ) -> flatbuffers::WIPOffset<PlaylistStateChanged<'bldr>> {
    let mut builder = PlaylistStateChangedBuilder::new(_fbb);
    if let Some(x) = args.songs { builder.add_songs(x); }
    builder.finish()
  }


  #[inline]
  pub fn songs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Song<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Song>>>>(PlaylistStateChanged::VT_SONGS, None)}
  }
}

impl flatbuffers::Verifiable for PlaylistStateChanged<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Song>>>>("songs", Self::VT_SONGS, false)?
     .finish();
    Ok(())
  }
}
pub struct PlaylistStateChangedArgs<'a> {
    pub songs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Song<'a>>>>>,
}
impl<'a> Default for PlaylistStateChangedArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlaylistStateChangedArgs {
      songs: None,
    }
  }
}

pub struct PlaylistStateChangedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaylistStateChangedBuilder<'a, 'b> {
  #[inline]
  pub fn add_songs(&mut self, songs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Song<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistStateChanged::VT_SONGS, songs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaylistStateChangedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaylistStateChangedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaylistStateChanged<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlaylistStateChanged<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlaylistStateChanged");
      ds.field("songs", &self.songs());
      ds.finish()
  }
}
pub enum PlaylistCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlaylistCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaylistCommand<'a> {
  type Inner = PlaylistCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlaylistCommand<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlaylistCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlaylistCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<PlaylistCommand<'bldr>> {
    let mut builder = PlaylistCommandBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaylistCommand::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn command_type(&self) -> PlaylistCommandContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlaylistCommandContent>(PlaylistCommand::VT_COMMAND_TYPE, Some(PlaylistCommandContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PlaylistCommand::VT_COMMAND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_add_song(&self) -> Option<AddSong<'a>> {
    if self.command_type() == PlaylistCommandContent::AddSong {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { AddSong::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_replace_song(&self) -> Option<ReplaceSong<'a>> {
    if self.command_type() == PlaylistCommandContent::ReplaceSong {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReplaceSong::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_remove_song(&self) -> Option<RemoveSong<'a>> {
    if self.command_type() == PlaylistCommandContent::RemoveSong {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RemoveSong::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_insert_song(&self) -> Option<InsertSong<'a>> {
    if self.command_type() == PlaylistCommandContent::InsertSong {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { InsertSong::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PlaylistCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<PlaylistCommandContent, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, false, |key, v, pos| {
        match key {
          PlaylistCommandContent::AddSong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddSong>>("PlaylistCommandContent::AddSong", pos),
          PlaylistCommandContent::ReplaceSong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReplaceSong>>("PlaylistCommandContent::ReplaceSong", pos),
          PlaylistCommandContent::RemoveSong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RemoveSong>>("PlaylistCommandContent::RemoveSong", pos),
          PlaylistCommandContent::InsertSong => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InsertSong>>("PlaylistCommandContent::InsertSong", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PlaylistCommandArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub command_type: PlaylistCommandContent,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PlaylistCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlaylistCommandArgs {
      device_id: None,
      command_type: PlaylistCommandContent::NONE,
      command: None,
    }
  }
}

pub struct PlaylistCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaylistCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistCommand::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_command_type(&mut self, command_type: PlaylistCommandContent) {
    self.fbb_.push_slot::<PlaylistCommandContent>(PlaylistCommand::VT_COMMAND_TYPE, command_type, PlaylistCommandContent::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistCommand::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaylistCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaylistCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaylistCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlaylistCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlaylistCommand");
      ds.field("device_id", &self.device_id());
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        PlaylistCommandContent::AddSong => {
          if let Some(x) = self.command_as_add_song() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlaylistCommandContent::ReplaceSong => {
          if let Some(x) = self.command_as_replace_song() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlaylistCommandContent::RemoveSong => {
          if let Some(x) = self.command_as_remove_song() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlaylistCommandContent::InsertSong => {
          if let Some(x) = self.command_as_insert_song() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
pub enum PlaylistQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlaylistQuery<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaylistQuery<'a> {
  type Inner = PlaylistQuery<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlaylistQuery<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_QUERY_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_QUERY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlaylistQuery { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlaylistQueryArgs<'args>
  ) -> flatbuffers::WIPOffset<PlaylistQuery<'bldr>> {
    let mut builder = PlaylistQueryBuilder::new(_fbb);
    if let Some(x) = args.query { builder.add_query(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_query_type(args.query_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaylistQuery::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn query_type(&self) -> PlaylistQueryContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlaylistQueryContent>(PlaylistQuery::VT_QUERY_TYPE, Some(PlaylistQueryContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn query(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PlaylistQuery::VT_QUERY, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn query_as_query_playlist_state(&self) -> Option<QueryPlaylistState<'a>> {
    if self.query_type() == PlaylistQueryContent::QueryPlaylistState {
      self.query().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { QueryPlaylistState::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PlaylistQuery<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<PlaylistQueryContent, _>("query_type", Self::VT_QUERY_TYPE, "query", Self::VT_QUERY, false, |key, v, pos| {
        match key {
          PlaylistQueryContent::QueryPlaylistState => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QueryPlaylistState>>("PlaylistQueryContent::QueryPlaylistState", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PlaylistQueryArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query_type: PlaylistQueryContent,
    pub query: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PlaylistQueryArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlaylistQueryArgs {
      device_id: None,
      query_type: PlaylistQueryContent::NONE,
      query: None,
    }
  }
}

pub struct PlaylistQueryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaylistQueryBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistQuery::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_query_type(&mut self, query_type: PlaylistQueryContent) {
    self.fbb_.push_slot::<PlaylistQueryContent>(PlaylistQuery::VT_QUERY_TYPE, query_type, PlaylistQueryContent::NONE);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistQuery::VT_QUERY, query);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaylistQueryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaylistQueryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaylistQuery<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlaylistQuery<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlaylistQuery");
      ds.field("device_id", &self.device_id());
      ds.field("query_type", &self.query_type());
      match self.query_type() {
        PlaylistQueryContent::QueryPlaylistState => {
          if let Some(x) = self.query_as_query_playlist_state() {
            ds.field("query", &x)
          } else {
            ds.field("query", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("query", &x)
        },
      };
      ds.finish()
  }
}
pub enum PlaylistEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlaylistEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlaylistEvent<'a> {
  type Inner = PlaylistEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlaylistEvent<'a> {
  pub const VT_DEVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_EVENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlaylistEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlaylistEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PlaylistEvent<'bldr>> {
    let mut builder = PlaylistEventBuilder::new(_fbb);
    if let Some(x) = args.event { builder.add_event(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.add_event_type(args.event_type);
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlaylistEvent::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn event_type(&self) -> PlaylistEventContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlaylistEventContent>(PlaylistEvent::VT_EVENT_TYPE, Some(PlaylistEventContent::NONE)).unwrap()}
  }
  #[inline]
  pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PlaylistEvent::VT_EVENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_playlist_state_changed(&self) -> Option<PlaylistStateChanged<'a>> {
    if self.event_type() == PlaylistEventContent::PlaylistStateChanged {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlaylistStateChanged::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PlaylistEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_union::<PlaylistEventContent, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, false, |key, v, pos| {
        match key {
          PlaylistEventContent::PlaylistStateChanged => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlaylistStateChanged>>("PlaylistEventContent::PlaylistStateChanged", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct PlaylistEventArgs<'a> {
    pub device_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_type: PlaylistEventContent,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PlaylistEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlaylistEventArgs {
      device_id: None,
      event_type: PlaylistEventContent::NONE,
      event: None,
    }
  }
}

pub struct PlaylistEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlaylistEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistEvent::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_event_type(&mut self, event_type: PlaylistEventContent) {
    self.fbb_.push_slot::<PlaylistEventContent>(PlaylistEvent::VT_EVENT_TYPE, event_type, PlaylistEventContent::NONE);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlaylistEvent::VT_EVENT, event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlaylistEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlaylistEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlaylistEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlaylistEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlaylistEvent");
      ds.field("device_id", &self.device_id());
      ds.field("event_type", &self.event_type());
      match self.event_type() {
        PlaylistEventContent::PlaylistStateChanged => {
          if let Some(x) = self.event_as_playlist_state_changed() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("event", &x)
        },
      };
      ds.finish()
  }
}
